#BlueJ class context
comment0.params=
comment0.target=UtilIan()
comment0.text=Hide\ the\ constructor,\ since\ this\ is\ a\ utility\ class.
comment1.params=c
comment1.target=java.lang.String\ charToString(java.lang.Character)
comment1.text=\ Convert\ a\ char\ to\ a\ String.\n\ @param\ c\ The\ Character\ to\ convert\ to\ a\ String.\n\ @return\ A\ String\ of\ length\ 1,\ corresponding\ to\ c.\n
comment10.params=str1\ str2
comment10.target=boolean\ equalsIgnoreWhitespace(java.lang.String,\ java.lang.String)
comment10.text=\ Return\ whether\ two\ Strings\ are\ equal,\ ignoring\ differences\ in\ whitespace.\n\ @param\ str1\ The\ first\ String\ to\ compare.\n\ @param\ str1\ The\ second\ String\ to\ compare.\n\ @return\ true\ iff\ str1\ equals\ str2,\ ignoring\ whitespace.\n
comment11.params=str1\ str2\ splitBy
comment11.target=boolean\ equalsIgnoreWhitespace(java.lang.String,\ java.lang.String,\ java.lang.String)
comment11.text=\ Return\ whether\ two\ Strings\ are\ equal,\ ignoring\ differences\ in\ whitespace.\n\ @param\ str1\ The\ first\ String\ to\ compare.\n\ @param\ str1\ The\ second\ String\ to\ compare.\n\ @param\ splitBy\ Characters\ to\ split\ by.\ \ If\ you\ split\ by\ ".?\!",\n\ \ \ .even\ "hi?"\ and\ "hi\ ?"\ will\ be\ equalsIgnoreWhitespace.\n\ @return\ true\ iff\ str1\ equals\ str2,\ ignoring\ whitespace.\n
comment12.params=s\ c
comment12.target=boolean\ hasNextChar(java.util.Scanner,\ char)
comment12.text=\ Is\ a\ certain\ character\ next,\ in\ a\ scanner's\ input\ (skipping\ whitespace)?\n\ \ This\ method\ may\ advance\ the\ scanner\ over\ any\ whitespace.\n\ @param\ s\ The\ scanner\ to\ read\ from.\n\ @param\ c\ The\ char\ to\ read.\n\ @return\ Whether\ c\ is\ the\ next\ (non-white)\ char\ at\ the\ front\ of\ s.\n
comment13.params=s
comment13.target=boolean\ hasNextChar(java.util.Scanner)
comment13.text=\ Is\ there\ a\ next\ (non-white)\ character\ to\ read\ from\ a\ scanner?\n\ Same\ as\ hasNext();\ provided\ for\ completeness.\n\ @param\ s\ The\ scanner\ to\ read\ from.\n\ @return\ Whether\ s\ has\ any\ (non-white)\ input\ to\ read.\n
comment14.params=s\ c
comment14.target=java.lang.Character\ nextChar(java.util.Scanner,\ char)
comment14.text=\ Read\ the\ given\ character\ from\ a\ scanner's\ input\ (skipping\ whitespace).\n\ @param\ s\ The\ scanner\ to\ read\ from.\n\ @param\ c\ The\ char\ to\ read.\n\ @return\ new\ Character(c),\ or\ null\ if\ c\ is\ not\ at\ the\ front\ of\ s's\ input\ (skipping\ whitespace).\n
comment15.params=s
comment15.target=java.lang.Character\ nextChar(java.util.Scanner)
comment15.text=\ Read\ the\ next\ char\ from\ a\ scanner's\ input\ (skipping\ whitespace).\n\ @param\ s\ The\ scanner\ to\ read\ from.\n\ @return\ the\ Character\ at\ the\ front\ of\ s's\ input\ (skipping\ whitespace).\n
comment16.params=s\ delimiterChars
comment16.target=java.lang.String\ nextSplittingBy(java.util.Scanner,\ java.lang.String)
comment16.text=\ Read\ a\ token,\ but\ stopping\ (and\ not\ consuming)\ if\ we\ encounter\ one\ of\ delimiterChars.\n\ \ If\ the\ token\ starts\ with\ one\ of\ delimiterChars,.even\ return\ that\ one\ char.\n\ \ (Initial\ whitespace\ is\ skipped,\ and\ one\ trailing\ whitespace\ might\ be\ consumed.)\n\ @param\ s\ The\ scanner\ to\ read\ from.\n\ @param\ delimiterChars\ Characters\ to\ be\ treated\ as\ delimiters\ *within*\ a\ single\ scanner\ token.\n\ \ \ \ \ \ \ \ If\ there\ are\ any\ special\ characters,\ they\ must\ *already*\ be\ quoted.\n\ @return\ the\ portion\ of\ the\ next\ token\ up\ until\ a\ delimiter,\n\ \ or\ (if\ the\ token\ starts\ with\ a\ delimiter)\ the\ initial\ delimiter\ itself\ (length\ 1).\n
comment17.params=s\ word\ delimiterChars
comment17.target=boolean\ hasNextSplittingBy(java.util.Scanner,\ java.lang.String,\ java.lang.String)
comment17.text=\n\ Does\ the\ scanner's\ next\ token\ start\ with\ a\ given\ word,\n\ \ \ \ \ optionally\ followed\ by\:\ any\ of\ delimiterChars\ (and.even\ other\ chars).\n\ Does\ not\ consume\ any\ input\ (but\ may\ advance\ past\ initial\ whitespace?).\n\ @param\ s\ The\ scanner\ to\ read\ from.\n\ @param\ word\ The\ initial\ word\ to\ look\ for,\ in\ the\ first\ token.\n\ @param\ delimiterChars\ Characters\ to\ be\ treated\ as\ delimiters\ *within*\ a\ scanner\ token.\n\ \ \ \ \ \ \ \ If\ there\ are\ any\ special\ characters,\ they\ must\ *already*\ be\ quoted.\n\ @return\ whether\ s's\ next\ token\ starts\ with\ word,\n\ \ \ \ \ optionally\ followed\ by\:\ any\ of\ delimiterChars\ (and.even\ other\ chars).\n\ \ \ \ \ \ \ \ \n\ For\ example,\ \n\ \ \ hasNextSplittingBy(\ new\ Scanner("hello"),\ \ \ \ \ \ "hello",\ "{}"\ )\ \=\=\ true\n\ \ \ hasNextSplittingBy(\ new\ Scanner("hello{bye}"),\ "hello",\ "{}"\ )\ \=\=\ true\n\ \ \ hasNextSplittingBy(\ new\ Scanner("hello{bye}"),\ "hell",\ \ "{}"\ )\ \=\=\ false\n
comment18.params=s\ delimiterChars
comment18.target=boolean\ hasNextDoubleSplittingBy(java.util.Scanner,\ java.lang.String)
comment19.params=s\ delimiterChars
comment19.target=double\ nextDoubleSplittingBy(java.util.Scanner,\ java.lang.String)
comment2.params=i
comment2.target=double\ intToDouble(java.lang.Integer)
comment2.text=\ Convert\ an\ Integer\ into\ to\ a\ double.\ \ Same\ as\ casting\ (but\ w/o\ new\ syntax.)\n\ @param\ i\ The\ Integer\ to\ convert\ to\ a\ double.\n\ @return\ The\ double\ corresponding\ to\ i.\n
comment20.params=s
comment20.target=void\ skipWhitespace(java.util.Scanner)
comment20.text=\ Skip\ over\ the\ whitespace\ in\ a\ Scanner.\ \ Not\ helpful\ unless\ you\ use\ methods\ which\n\ ignore\ delimiters\ (such\ as\ Scanner.findWithinHorizon).\n\ @param\ s\ The\ scanner\ to\ skip\ over\ whitespace.\n
comment21.params=s\ pat
comment21.target=java.lang.String\ nextMatch(java.util.Scanner,\ java.lang.String)
comment21.text=\ Return\ the\ next\ match\ (skipping\ initial\ whitespace)\ of\ a\ pattern.\n\ Note\:\ there\ is\ no\ corresponding\ 'hasNextMatch'\ method;\ this\ method\ \ either\ returns\n\ the\ matched\ String,\ or\ null.\n\ \n\ @param\ s\ The\ scanner\ to\ read\ from.\n\ @param\ pat\ The\ pattern\ to\ look\ for.\n\ @return\ The\ String\ matching\ the\ given\ pattern;\ if\ the\ front\ of\ the\ input\ doesn't\n\ match\ the\ pattern.even\ null\ is\ returned\ and\ the\ scanner\ is\ does\ not\ consume\ any\ input.\n\ (N.B.\ A\ *large*\ amount\ of\ input\ might\ be\ buffered,\ depending\ on\ the\ pattern.)\n
comment22.params=s\ pat
comment22.target=java.lang.String\ nextMatch(java.util.Scanner,\ java.util.regex.Pattern)
comment22.text=\ Return\ the\ next\ match\ (skipping\ initial\ whitespace)\ of\ a\ pattern.\n\ Note\:\ there\ is\ no\ corresponding\ 'hasNextMatch'\ method;\ this\ method\ either\ returns\n\ (and\ consumes)\ the\ matched\ String,\ or\ null.\n\ \n\ @param\ s\ The\ scanner\ to\ read\ from.\n\ @param\ pat\ The\ pattern\ to\ look\ for.\n\ @return\ The\ String\ matching\ the\ given\ pattern;\ if\ the\ front\ of\ the\ input\ doesn't\n\ match\ the\ pattern.even\ null\ is\ returned\ and\ the\ scanner\ is\ does\ not\ consume\ any\ input.\n\ (N.B.\ A\ *large*\ amount\ of\ input\ might\ be\ buffered,\ depending\ on\ the\ pattern.)\n
comment23.params=ts
comment23.target=java.lang.Comparable\ max(java.util.Collection)
comment23.text=\ Return\ the\ maximum\ item\ in\ a\ Collection<Comparable>.\n\ @param\ ts\ A\ collection\ of\ comparable\ objects.\n\ @return\ the\ (first)\ largest\ element\ in\ ts.\n
comment24.params=ts
comment24.target=java.lang.Comparable\ min(java.util.Collection)
comment24.text=\ Return\ the\ minimum\ item\ in\ a\ Collection<Comparable>.\n\ @param\ ts\ A\ collection\ of\ comparable\ objects.\n\ @return\ the\ (first)\ smallest\ element\ in\ ts.\n
comment25.params=ts
comment25.target=java.lang.Comparable\ max(java.lang.Comparable[])
comment25.text=\ A\ var-args\ version\ of\ max(Collection).\n\ @see\ UtilIan.max(Collection).\n
comment26.params=ts
comment26.target=java.lang.Comparable\ min(java.lang.Comparable[])
comment26.text=\ A\ var-args\ version\ of\ min(Collection).\n\ @see\ UtilIan.min(Collection).\n
comment3.params=d
comment3.target=int\ doubleToInt(java.lang.Double)
comment3.text=\ Convert\ a\ Double\ to\ an\ int.\ \ Same\ as\ casting\ (but\ w/o\ new\ syntax.)\n\ @param\ d\ The\ Double\ to\ convert\ to\ an\ int.\n\ @return\ The\ int\ corresponding\ to\ d.\n
comment4.params=x
comment4.target=int\ roundToInt(double)
comment4.text=\ Round\ a\ Double\ to\ the\ nearest\ int.\ \ Same\ as\ Math.round,\ but\ returns\ an\ int.\n\ (Does\ *not*\ round-to-even,\ since\ java.lang.Math.round\ doesn't.)\n\ @param\ x\ The\ Double\ to\ round.\n\ @return\ The\ int\ nearest\ x\ (rounded\ as\ per\ Math.round).\n
comment5.params=x
comment5.target=int\ ceil(double)
comment5.text=\ The\ smallest\ int\ &ge;\ to\ x\ (same\ as\ Math.ceil,\ but\ returns\ int.)\n\ @param\ d\ The\ double\ to\ find\ the\ ceiling\ of.\n\ @return\ The\ smallest\ int\ &ge;\ x.\n
comment6.params=x
comment6.target=int\ floor(double)
comment6.text=\ The\ largest\ int\ &le;\ to\ x\ (same\ as\ Math.floor,\ but\ returns\ int.)\n\ @param\ x\ The\ double\ to\ find\ the\ floor\ of.\n\ @return\ The\ larest\ int\ &le;\ x.\n
comment7.params=x\ places
comment7.target=double\ roundTo(double,\ int)
comment7.text=\ Round\ a\ number\ to\ a\ certain\ number\ of\ decimal\ places.\n\ @param\ x\ The\ number\ to\ round.\n\ @param\ places\ The\ number\ of\ decimal\ places\ to\ round\ to.\ \ Can\ be\ negative.\n\ @return\ The\ double\ corresponding\ to\ i.\n
comment8.params=d1\ d2
comment8.target=boolean\ equalsApprox(double,\ double)
comment8.text=\ Return\ whether\ two\ doubles\ are\ equal\ (approximately).\n\ This\ function\ is\ symmetric.\n\ \ \ \ TODO\:\ detail\ what\ happens\ if\ d1\ or\ d2\ is\ zero.\n\ @param\ d1\ A\ double\ to\ compare.\n\ @param\ d2\ A\ double\ to\ compare.\n\ @return\ true\ iff\ d1\ is\ close\ to\ d2\ (within\ a\ factor\ of\ {UtilIan.TOLERANCE}).\n
comment9.params=d1\ d2\ relativeTolerance
comment9.target=boolean\ equalsApprox(double,\ double,\ double)
numComments=27
