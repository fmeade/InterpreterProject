<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_65) on Fri Nov 08 13:41:09 EST 2013 -->
<META http-equiv="Content-Type" content="text/html; charset=MacRoman">
<TITLE>
UtilIan
</TITLE>

<META NAME="date" CONTENT="2013-11-08">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="UtilIan";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
Class UtilIan</H2>
<PRE>
java.lang.Object
  <IMG SRC="./resources/inherit.gif" ALT="extended by "><B>UtilIan</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>UtilIan</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#Digits">Digits</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#DOUBLE_PATTERN">DOUBLE_PATTERN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#Exp">Exp</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#ceil(double)">ceil</A></B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The smallest int &ge; to x (same as Math.ceil, but returns int.)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#charToString(java.lang.Character)">charToString</A></B>(java.lang.Character&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convert a char to a String.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#doubleToInt(java.lang.Double)">doubleToInt</A></B>(java.lang.Double&nbsp;d)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convert a Double to an int.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#equalsApprox(double, double)">equalsApprox</A></B>(double&nbsp;d1,
             double&nbsp;d2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return whether two doubles are equal (approximately).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#equalsApprox(double, double, double)">equalsApprox</A></B>(double&nbsp;d1,
             double&nbsp;d2,
             double&nbsp;relativeTolerance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#equalsIgnoreWhitespace(java.lang.String, java.lang.String)">equalsIgnoreWhitespace</A></B>(java.lang.String&nbsp;str1,
                       java.lang.String&nbsp;str2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return whether two Strings are equal, ignoring differences in whitespace.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#equalsIgnoreWhitespace(java.lang.String, java.lang.String, java.lang.String)">equalsIgnoreWhitespace</A></B>(java.lang.String&nbsp;str1,
                       java.lang.String&nbsp;str2,
                       java.lang.String&nbsp;splitBy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return whether two Strings are equal, ignoring differences in whitespace.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#floor(double)">floor</A></B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The largest int &le; to x (same as Math.floor, but returns int.)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#hasNextChar(java.util.Scanner)">hasNextChar</A></B>(java.util.Scanner&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is there a next (non-white) character to read from a scanner?
 Same as hasNext(); provided for completeness.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#hasNextChar(java.util.Scanner, char)">hasNextChar</A></B>(java.util.Scanner&nbsp;s,
            char&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Is a certain character next, in a scanner's input (skipping whitespace)?
  This method may advance the scanner over any whitespace.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#hasNextDoubleSplittingBy(java.util.Scanner, java.lang.String)">hasNextDoubleSplittingBy</A></B>(java.util.Scanner&nbsp;s,
                         java.lang.String&nbsp;delimiterChars)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#hasNextSplittingBy(java.util.Scanner, java.lang.String, java.lang.String)">hasNextSplittingBy</A></B>(java.util.Scanner&nbsp;s,
                   java.lang.String&nbsp;word,
                   java.lang.String&nbsp;delimiterChars)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does the scanner's next token start with a given word,
     optionally followed by: any of delimiterChars (and then other chars).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#intToDouble(java.lang.Integer)">intToDouble</A></B>(java.lang.Integer&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Convert an Integer into to a double.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends java.lang.Comparable&lt;T&gt;&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#max(java.util.Collection)">max</A></B>(java.util.Collection&lt;T&gt;&nbsp;ts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the maximum item in a Collection<Comparable>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends java.lang.Comparable&lt;T&gt;&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#max(T...)">max</A></B>(T...&nbsp;ts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A var-args version of max(Collection).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends java.lang.Comparable&lt;T&gt;&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#min(java.util.Collection)">min</A></B>(java.util.Collection&lt;T&gt;&nbsp;ts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the minimum item in a Collection<Comparable>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends java.lang.Comparable&lt;T&gt;&gt; 
<BR>
T</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#min(T...)">min</A></B>(T...&nbsp;ts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A var-args version of min(Collection).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Character</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#nextChar(java.util.Scanner)">nextChar</A></B>(java.util.Scanner&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read the next char from a scanner's input (skipping whitespace).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.Character</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#nextChar(java.util.Scanner, char)">nextChar</A></B>(java.util.Scanner&nbsp;s,
         char&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read the given character from a scanner's input (skipping whitespace).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#nextDoubleSplittingBy(java.util.Scanner, java.lang.String)">nextDoubleSplittingBy</A></B>(java.util.Scanner&nbsp;s,
                      java.lang.String&nbsp;delimiterChars)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#nextMatch(java.util.Scanner, java.util.regex.Pattern)">nextMatch</A></B>(java.util.Scanner&nbsp;s,
          java.util.regex.Pattern&nbsp;pat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the next match (skipping initial whitespace) of a pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#nextMatch(java.util.Scanner, java.lang.String)">nextMatch</A></B>(java.util.Scanner&nbsp;s,
          java.lang.String&nbsp;pat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the next match (skipping initial whitespace) of a pattern.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#nextSplittingBy(java.util.Scanner, java.lang.String)">nextSplittingBy</A></B>(java.util.Scanner&nbsp;s,
                java.lang.String&nbsp;delimiterChars)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read a token, but stopping (and not consuming) if we encounter one of delimiterChars.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#roundTo(double, int)">roundTo</A></B>(double&nbsp;x,
        int&nbsp;places)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Round a number to a certain number of decimal places.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#roundToInt(double)">roundToInt</A></B>(double&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Round a Double to the nearest int.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="UtilIan.html#skipWhitespace(java.util.Scanner)">skipWhitespace</A></B>(java.util.Scanner&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Skip over the whitespace in a Scanner.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Digits"><!-- --></A><H3>
Digits</H3>
<PRE>
static final java.lang.String <B>Digits</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="constant-values.html#UtilIan.Digits">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DOUBLE_PATTERN"><!-- --></A><H3>
DOUBLE_PATTERN</H3>
<PRE>
public static final java.lang.String <B>DOUBLE_PATTERN</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="constant-values.html#UtilIan.DOUBLE_PATTERN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="Exp"><!-- --></A><H3>
Exp</H3>
<PRE>
static final java.lang.String <B>Exp</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="constant-values.html#UtilIan.Exp">Constant Field Values</A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ceil(double)"><!-- --></A><H3>
ceil</H3>
<PRE>
public static int <B>ceil</B>(double&nbsp;x)</PRE>
<DL>
<DD>The smallest int &ge; to x (same as Math.ceil, but returns int.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - The double to find the ceiling of.
<DT><B>Returns:</B><DD>The smallest int &ge; x.</DL>
</DD>
</DL>
<HR>

<A NAME="charToString(java.lang.Character)"><!-- --></A><H3>
charToString</H3>
<PRE>
public static java.lang.String <B>charToString</B>(java.lang.Character&nbsp;c)</PRE>
<DL>
<DD>Convert a char to a String.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>c</CODE> - The Character to convert to a String.
<DT><B>Returns:</B><DD>A String of length 1, corresponding to c.</DL>
</DD>
</DL>
<HR>

<A NAME="doubleToInt(java.lang.Double)"><!-- --></A><H3>
doubleToInt</H3>
<PRE>
public static int <B>doubleToInt</B>(java.lang.Double&nbsp;d)</PRE>
<DL>
<DD>Convert a Double to an int.  Same as casting (but w/o new syntax.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d</CODE> - The Double to convert to an int.
<DT><B>Returns:</B><DD>The int corresponding to d.</DL>
</DD>
</DL>
<HR>

<A NAME="equalsApprox(double, double)"><!-- --></A><H3>
equalsApprox</H3>
<PRE>
public static boolean <B>equalsApprox</B>(double&nbsp;d1,
                                   double&nbsp;d2)</PRE>
<DL>
<DD>Return whether two doubles are equal (approximately).
 This function is symmetric.
    TODO: detail what happens if d1 or d2 is zero.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>d1</CODE> - A double to compare.<DD><CODE>d2</CODE> - A double to compare.
<DT><B>Returns:</B><DD>true iff d1 is close to d2 (within a factor of {UtilIan.TOLERANCE}).</DL>
</DD>
</DL>
<HR>

<A NAME="equalsApprox(double, double, double)"><!-- --></A><H3>
equalsApprox</H3>
<PRE>
public static boolean <B>equalsApprox</B>(double&nbsp;d1,
                                   double&nbsp;d2,
                                   double&nbsp;relativeTolerance)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="equalsIgnoreWhitespace(java.lang.String, java.lang.String)"><!-- --></A><H3>
equalsIgnoreWhitespace</H3>
<PRE>
public static boolean <B>equalsIgnoreWhitespace</B>(java.lang.String&nbsp;str1,
                                             java.lang.String&nbsp;str2)</PRE>
<DL>
<DD>Return whether two Strings are equal, ignoring differences in whitespace.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>str1</CODE> - The first String to compare.<DD><CODE>str1</CODE> - The second String to compare.
<DT><B>Returns:</B><DD>true iff str1 equals str2, ignoring whitespace.</DL>
</DD>
</DL>
<HR>

<A NAME="equalsIgnoreWhitespace(java.lang.String, java.lang.String, java.lang.String)"><!-- --></A><H3>
equalsIgnoreWhitespace</H3>
<PRE>
public static boolean <B>equalsIgnoreWhitespace</B>(java.lang.String&nbsp;str1,
                                             java.lang.String&nbsp;str2,
                                             java.lang.String&nbsp;splitBy)</PRE>
<DL>
<DD>Return whether two Strings are equal, ignoring differences in whitespace.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>str1</CODE> - The first String to compare.<DD><CODE>str1</CODE> - The second String to compare.<DD><CODE>splitBy</CODE> - Characters to split by.  If you split by ".?!",
    then "hi?" and "hi ?" will be equalsIgnoreWhitespace.
<DT><B>Returns:</B><DD>true iff str1 equals str2, ignoring whitespace.</DL>
</DD>
</DL>
<HR>

<A NAME="floor(double)"><!-- --></A><H3>
floor</H3>
<PRE>
public static int <B>floor</B>(double&nbsp;x)</PRE>
<DL>
<DD>The largest int &le; to x (same as Math.floor, but returns int.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - The double to find the floor of.
<DT><B>Returns:</B><DD>The larest int &le; x.</DL>
</DD>
</DL>
<HR>

<A NAME="hasNextChar(java.util.Scanner)"><!-- --></A><H3>
hasNextChar</H3>
<PRE>
public static boolean <B>hasNextChar</B>(java.util.Scanner&nbsp;s)</PRE>
<DL>
<DD>Is there a next (non-white) character to read from a scanner?
 Same as hasNext(); provided for completeness.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The scanner to read from.
<DT><B>Returns:</B><DD>Whether s has any (non-white) input to read.</DL>
</DD>
</DL>
<HR>

<A NAME="hasNextChar(java.util.Scanner, char)"><!-- --></A><H3>
hasNextChar</H3>
<PRE>
public static boolean <B>hasNextChar</B>(java.util.Scanner&nbsp;s,
                                  char&nbsp;c)</PRE>
<DL>
<DD>Is a certain character next, in a scanner's input (skipping whitespace)?
  This method may advance the scanner over any whitespace.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The scanner to read from.<DD><CODE>c</CODE> - The char to read.
<DT><B>Returns:</B><DD>Whether c is the next (non-white) char at the front of s.</DL>
</DD>
</DL>
<HR>

<A NAME="hasNextDoubleSplittingBy(java.util.Scanner, java.lang.String)"><!-- --></A><H3>
hasNextDoubleSplittingBy</H3>
<PRE>
public static boolean <B>hasNextDoubleSplittingBy</B>(java.util.Scanner&nbsp;s,
                                               java.lang.String&nbsp;delimiterChars)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="hasNextSplittingBy(java.util.Scanner, java.lang.String, java.lang.String)"><!-- --></A><H3>
hasNextSplittingBy</H3>
<PRE>
public static boolean <B>hasNextSplittingBy</B>(java.util.Scanner&nbsp;s,
                                         java.lang.String&nbsp;word,
                                         java.lang.String&nbsp;delimiterChars)</PRE>
<DL>
<DD>Does the scanner's next token start with a given word,
     optionally followed by: any of delimiterChars (and then other chars).
 Does not consume any input (but may advance past initial whitespace?).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The scanner to read from.<DD><CODE>word</CODE> - The initial word to look for, in the first token.<DD><CODE>delimiterChars</CODE> - Characters to be treated as delimiters *within* a scanner token.
        If there are any special characters, they must *already* be quoted.
<DT><B>Returns:</B><DD>whether s's next token starts with word,
     optionally followed by: any of delimiterChars (and then other chars).
        
 For example, 
   hasNextSplittingBy( new Scanner("hello"),      "hello", "{}" ) == true
   hasNextSplittingBy( new Scanner("hello{bye}"), "hello", "{}" ) == true
   hasNextSplittingBy( new Scanner("hello{bye}"), "hell",  "{}" ) == false</DL>
</DD>
</DL>
<HR>

<A NAME="intToDouble(java.lang.Integer)"><!-- --></A><H3>
intToDouble</H3>
<PRE>
public static double <B>intToDouble</B>(java.lang.Integer&nbsp;i)</PRE>
<DL>
<DD>Convert an Integer into to a double.  Same as casting (but w/o new syntax.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - The Integer to convert to a double.
<DT><B>Returns:</B><DD>The double corresponding to i.</DL>
</DD>
</DL>
<HR>

<A NAME="max(java.util.Collection)"><!-- --></A><H3>
max</H3>
<PRE>
public static &lt;T extends java.lang.Comparable&lt;T&gt;&gt; T <B>max</B>(java.util.Collection&lt;T&gt;&nbsp;ts)</PRE>
<DL>
<DD>Return the maximum item in a Collection<Comparable>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ts</CODE> - A collection of comparable objects.
<DT><B>Returns:</B><DD>the (first) largest element in ts.</DL>
</DD>
</DL>
<HR>

<A NAME="max(java.lang.Comparable[])"><!-- --></A><A NAME="max(T...)"><!-- --></A><H3>
max</H3>
<PRE>
public static &lt;T extends java.lang.Comparable&lt;T&gt;&gt; T <B>max</B>(T...&nbsp;ts)</PRE>
<DL>
<DD>A var-args version of max(Collection).
<P>
<DD><DL>
<DT><B>See Also:</B><DD><CODE>UtilIan.max(Collection).</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="min(java.util.Collection)"><!-- --></A><H3>
min</H3>
<PRE>
public static &lt;T extends java.lang.Comparable&lt;T&gt;&gt; T <B>min</B>(java.util.Collection&lt;T&gt;&nbsp;ts)</PRE>
<DL>
<DD>Return the minimum item in a Collection<Comparable>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ts</CODE> - A collection of comparable objects.
<DT><B>Returns:</B><DD>the (first) smallest element in ts.</DL>
</DD>
</DL>
<HR>

<A NAME="min(java.lang.Comparable[])"><!-- --></A><A NAME="min(T...)"><!-- --></A><H3>
min</H3>
<PRE>
public static &lt;T extends java.lang.Comparable&lt;T&gt;&gt; T <B>min</B>(T...&nbsp;ts)</PRE>
<DL>
<DD>A var-args version of min(Collection).
<P>
<DD><DL>
<DT><B>See Also:</B><DD><CODE>UtilIan.min(Collection).</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="nextChar(java.util.Scanner)"><!-- --></A><H3>
nextChar</H3>
<PRE>
public static java.lang.Character <B>nextChar</B>(java.util.Scanner&nbsp;s)</PRE>
<DL>
<DD>Read the next char from a scanner's input (skipping whitespace).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The scanner to read from.
<DT><B>Returns:</B><DD>the Character at the front of s's input (skipping whitespace).</DL>
</DD>
</DL>
<HR>

<A NAME="nextChar(java.util.Scanner, char)"><!-- --></A><H3>
nextChar</H3>
<PRE>
public static java.lang.Character <B>nextChar</B>(java.util.Scanner&nbsp;s,
                                           char&nbsp;c)</PRE>
<DL>
<DD>Read the given character from a scanner's input (skipping whitespace).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The scanner to read from.<DD><CODE>c</CODE> - The char to read.
<DT><B>Returns:</B><DD>new Character(c), or null if c is not at the front of s's input (skipping whitespace).</DL>
</DD>
</DL>
<HR>

<A NAME="nextDoubleSplittingBy(java.util.Scanner, java.lang.String)"><!-- --></A><H3>
nextDoubleSplittingBy</H3>
<PRE>
public static double <B>nextDoubleSplittingBy</B>(java.util.Scanner&nbsp;s,
                                           java.lang.String&nbsp;delimiterChars)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nextMatch(java.util.Scanner, java.util.regex.Pattern)"><!-- --></A><H3>
nextMatch</H3>
<PRE>
public static java.lang.String <B>nextMatch</B>(java.util.Scanner&nbsp;s,
                                         java.util.regex.Pattern&nbsp;pat)</PRE>
<DL>
<DD>Return the next match (skipping initial whitespace) of a pattern.
 Note: there is no corresponding 'hasNextMatch' method; this method either returns
 (and consumes) the matched String, or null.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The scanner to read from.<DD><CODE>pat</CODE> - The pattern to look for.
<DT><B>Returns:</B><DD>The String matching the given pattern; if the front of the input doesn't
 match the pattern then null is returned and the scanner is does not consume any input.
 (N.B. A *large* amount of input might be buffered, depending on the pattern.)</DL>
</DD>
</DL>
<HR>

<A NAME="nextMatch(java.util.Scanner, java.lang.String)"><!-- --></A><H3>
nextMatch</H3>
<PRE>
public static java.lang.String <B>nextMatch</B>(java.util.Scanner&nbsp;s,
                                         java.lang.String&nbsp;pat)</PRE>
<DL>
<DD>Return the next match (skipping initial whitespace) of a pattern.
 Note: there is no corresponding 'hasNextMatch' method; this method  either returns
 the matched String, or null.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The scanner to read from.<DD><CODE>pat</CODE> - The pattern to look for.
<DT><B>Returns:</B><DD>The String matching the given pattern; if the front of the input doesn't
 match the pattern then null is returned and the scanner is does not consume any input.
 (N.B. A *large* amount of input might be buffered, depending on the pattern.)</DL>
</DD>
</DL>
<HR>

<A NAME="nextSplittingBy(java.util.Scanner, java.lang.String)"><!-- --></A><H3>
nextSplittingBy</H3>
<PRE>
public static java.lang.String <B>nextSplittingBy</B>(java.util.Scanner&nbsp;s,
                                               java.lang.String&nbsp;delimiterChars)</PRE>
<DL>
<DD>Read a token, but stopping (and not consuming) if we encounter one of delimiterChars.
  If the token starts with one of delimiterChars, then return that one char.
  (Initial whitespace is skipped, and one trailing whitespace might be consumed.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The scanner to read from.<DD><CODE>delimiterChars</CODE> - Characters to be treated as delimiters *within* a single scanner token.
        If there are any special characters, they must *already* be quoted.
<DT><B>Returns:</B><DD>the portion of the next token up until a delimiter,
  or (if the token starts with a delimiter) the initial delimiter itself (length 1).</DL>
</DD>
</DL>
<HR>

<A NAME="roundTo(double, int)"><!-- --></A><H3>
roundTo</H3>
<PRE>
public static double <B>roundTo</B>(double&nbsp;x,
                             int&nbsp;places)</PRE>
<DL>
<DD>Round a number to a certain number of decimal places.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - The number to round.<DD><CODE>places</CODE> - The number of decimal places to round to.  Can be negative.
<DT><B>Returns:</B><DD>The double corresponding to i.</DL>
</DD>
</DL>
<HR>

<A NAME="roundToInt(double)"><!-- --></A><H3>
roundToInt</H3>
<PRE>
public static int <B>roundToInt</B>(double&nbsp;x)</PRE>
<DL>
<DD>Round a Double to the nearest int.  Same as Math.round, but returns an int.
 (Does *not* round-to-even, since java.lang.Math.round doesn't.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - The Double to round.
<DT><B>Returns:</B><DD>The int nearest x (rounded as per Math.round).</DL>
</DD>
</DL>
<HR>

<A NAME="skipWhitespace(java.util.Scanner)"><!-- --></A><H3>
skipWhitespace</H3>
<PRE>
public static void <B>skipWhitespace</B>(java.util.Scanner&nbsp;s)</PRE>
<DL>
<DD>Skip over the whitespace in a Scanner.  Not helpful unless you use methods which
 ignore delimiters (such as Scanner.findWithinHorizon).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - The scanner to skip over whitespace.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<HR>

</BODY>
</HTML>
