#reader(lib"read.ss""wxme")WXME0108 ## 
#|
   This file uses the GRacket editor format.
   Open this file in DrRacket version 6.2.1 or later to read it.

   Most likely, it was created by saving a program in DrRacket,
   and it probably contains a program with non-text elements
   (such as images or comment boxes).

            http://racket-lang.org/
|#
 32 7 #"wxtext\0"
3 1 6 #"wxtab\0"
1 1 8 #"wximage\0"
2 0 8 #"wxmedia\0"
4 1 34 #"(lib \"syntax-browser.ss\" \"mrlib\")\0"
1 0 16 #"drscheme:number\0"
3 0 44 #"(lib \"number-snip.ss\" \"drscheme\" \"private\")\0"
1 0 36 #"(lib \"comment-snip.ss\" \"framework\")\0"
1 0 93
(
 #"((lib \"collapsed-snipclass.ss\" \"framework\") (lib \"collapsed-sni"
 #"pclass-wxme.ss\" \"framework\"))\0"
) 0 0 43 #"(lib \"collapsed-snipclass.ss\" \"framework\")\0"
0 0 19 #"drscheme:sexp-snip\0"
0 0 36 #"(lib \"cache-image-snip.ss\" \"mrlib\")\0"
1 0 68
(
 #"((lib \"image-core.ss\" \"mrlib\") (lib \"image-core-wxme.rkt\" \"mr"
 #"lib\"))\0"
) 1 0 29 #"drscheme:bindings-snipclass%\0"
1 0 101
(
 #"((lib \"ellipsis-snip.rkt\" \"drracket\" \"private\") (lib \"ellipsi"
 #"s-snip-wxme.rkt\" \"drracket\" \"private\"))\0"
) 2 0 88
(
 #"((lib \"pict-snip.rkt\" \"drracket\" \"private\") (lib \"pict-snip.r"
 #"kt\" \"drracket\" \"private\"))\0"
) 0 0 34 #"(lib \"bullet-snip.rkt\" \"browser\")\0"
0 0 25 #"(lib \"matrix.ss\" \"htdp\")\0"
1 0 22 #"drscheme:lambda-snip%\0"
1 0 29 #"drclickable-string-snipclass\0"
0 0 26 #"drracket:spacer-snipclass\0"
0 0 57
#"(lib \"hrule-snip.rkt\" \"macro-debugger\" \"syntax-browser\")\0"
1 0 26 #"drscheme:pict-value-snip%\0"
0 0 45 #"(lib \"image-snipr.ss\" \"slideshow\" \"private\")\0"
1 0 38 #"(lib \"pict-snipclass.ss\" \"slideshow\")\0"
2 0 55 #"(lib \"vertical-separator-snip.ss\" \"stepper\" \"private\")\0"
1 0 18 #"drscheme:xml-snip\0"
1 0 31 #"(lib \"xml-snipclass.ss\" \"xml\")\0"
1 0 21 #"drscheme:scheme-snip\0"
2 0 34 #"(lib \"scheme-snipclass.ss\" \"xml\")\0"
1 0 10 #"text-box%\0"
1 0 32 #"(lib \"text-snipclass.ss\" \"xml\")\0"
1 0 1 6 #"wxloc\0"
          0 0 56 0 1 #"\0"
0 75 1 #"\0"
0 12 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 0 9
#"Standard\0"
0 75 6 #"Menlo\0"
0 11 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 -1 -1 2 24
#"framework:default-color\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 255 255 255 -1 -1 2
1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 15
#"text:ports out\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 93 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 255 0 0 0 0 0 -1
-1 2 15 #"text:ports err\0"
0 -1 1 #"\0"
1 0 -1 92 93 -1 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 17
#"text:ports value\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 27 #"Matching Parenthesis Style\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 1 #"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:symbol\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 38
#"framework:syntax-color:scheme:keyword\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2
38 #"framework:syntax-color:scheme:comment\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:string\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 35
#"framework:syntax-color:scheme:text\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 39
#"framework:syntax-color:scheme:constant\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 49
#"framework:syntax-color:scheme:hash-colon-keyword\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 42
#"framework:syntax-color:scheme:parenthesis\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:error\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:other\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 16
#"Misspelled Text\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2
38 #"drracket:check-syntax:lexically-bound\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 28
#"drracket:check-syntax:set!d\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 37
#"drracket:check-syntax:unused-require\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"drracket:check-syntax:free-variable\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 31
#"drracket:check-syntax:imported\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 47
#"drracket:check-syntax:my-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 50
#"drracket:check-syntax:their-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 48
#"drracket:check-syntax:unk-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
49 #"drracket:check-syntax:both-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
26 #"plt:htdp:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 2 27
#"plt:htdp:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 4 1
#"\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 4 #"XML\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 2 37 #"plt:module-language:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 38
#"plt:module-language:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 92 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 4 1
#"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 1 #"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 100 0 0 0 0 -1
-1 2 1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 200 0 0 0 0 0 -1 -1
          0 1846 0 28 3 12 #"#lang racket"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 7 #"require"
0 0 24 3 1 #" "
0 0 19 3 7 #"\"Q.rkt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 7 #"require"
0 0 24 3 1 #" "
0 0 19 3 13 #"\"scanner.rkt\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 7 #"require"
0 0 24 3 1 #" "
0 0 14 3 8 #"rackunit"
0 0 24 3 2 #") "
0 0 17 3 41 #"; use `check-equal?`, not `check-expect`."
0 0 24 29 1 #"\n"
0 0 17 3 1 #";"
0 0 24 29 1 #"\n"
0 0 17 3 79
(
 #"; We use `check-equal?` because it can be passed as a function (e.g."
 #" to `map`)."
) 0 0 24 29 1 #"\n"
0 0 17 3 76
(
 #"; The one advantage of `check-expect` we lose, is that all check-exp"
 #"ects are"
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #"; delayed until the end of the file (hence, you can have a `check-ex"
 #"pect`"
) 0 0 24 29 1 #"\n"
0 0 17 3 65
#"; *before* the function it tests -- not so, with `check-equal?`.)"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;;;;;;;;;;;;;;;;;; TEST CASES: Q0 ;;;;;;;;;;;;;;;;"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 50 #"; Some expressions to test in a non-automated way:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"e0"
0 0 24 3 1 #" "
0 0 19 3 4 #"\"43\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 19 3 8 #"\"[[43]]\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 1 #" "
0 0 19 3 11 #"\"(4 add 3)\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"e3"
0 0 24 3 1 #" "
0 0 19 3 25 #"\"[[[[ [[ (4 add 3)]]]]]]\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 2 #"e4"
0 0 24 3 1 #" "
0 0 19 3 29 #"\"([[43]] add    ( 42 mul 3))\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 4 #"\"39\""
0 0 24 3 2 #") "
0 0 21 3 2 #"39"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 2 #"e4"
0 0 24 3 3 #")) "
0 0 21 3 3 #"169"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 66
#";;; three types of test we want to make, for many different exprs:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 11 #"\"(4 add 3)\""
0 0 24 3 3 #") ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"add\""
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 11 #"\"(4 add 3)\""
0 0 24 3 3 #")) "
0 0 21 3 1 #"7"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 11 #"\"(4 add 3)\""
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 14 #"              "
0 0 19 3 11 #"\"(4 add 3)\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"tests"
0 0 24 29 1 #"\n"
0 0 24 3 2 #"  "
0 0 17 3 34 #"; Each entry in the list is either"
0 0 24 29 1 #"\n"
0 0 24 3 2 #"  "
0 0 17 3 72
(
 #"; [str val] (where val is the result of interpreting the string str)"
 #", or"
) 0 0 24 29 1 #"\n"
0 0 24 3 2 #"  "
0 0 17 3 78
(
 #"; [str val expr] (as above, but expr is the internal (struct) repres"
 #"entation)."
) 0 0 24 29 1 #"\n"
0 0 24 3 2 #"  "
0 0 21 3 1 #"`"
0 0 24 3 2 #"{["
0 0 19 3 3 #"\"7\""
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ["
0 0 19 3 11 #"\"(3 add 4)\""
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 24 3 1 #"("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"add\""
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ["
0 0 19 3 13 #"\"(3 mul   4)\""
0 0 24 3 1 #" "
0 0 21 3 2 #"12"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 24 3 1 #"("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"mul\""
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ["
0 0 19 3 31 #"\"((3 add 4) add(  3  mul 4 ) )\""
0 0 24 3 1 #" "
0 0 21 3 2 #"19"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ["
0 0 19 3 26 #"\"parity 0 even: 1 odd: 2;\""
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 24 3 1 #"("
0 0 14 3 16 #"make-parity-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"0"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ["
0 0 19 3 26 #"\"parity 1 even: 1 odd: 2;\""
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 24 3 1 #"("
0 0 14 3 16 #"make-parity-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ["
0 0 19 3 35 #"\"parity (3 add -3) even: 1 odd: 2;\""
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 28 3 1 #","
0 0 24 3 1 #"("
0 0 14 3 16 #"make-parity-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"add\""
0 0 24 3 1 #" "
0 0 21 3 2 #"-3"
0 0 24 3 2 #") "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ["
0 0 19 3 83
(
 #"\"parity (parity parity 0 even: 1 odd: 2; even: 3 odd: 4 ; add -3) e"
 #"ven:  1 odd: 2;\""
) 0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 0 24 3 5 #"     "
0 0 21 3 1 #"2"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"     "
0 0 28 3 1 #","
0 0 24 3 1 #"("
0 0 14 3 16 #"make-parity-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 2 #" ("
0 0 14 3 16 #"make-parity-expr"
0 0 24 3 2 #" ("
0 0 14 3 16 #"make-parity-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"0"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 2 #") "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #") "
0 0 19 3 5 #"\"add\""
0 0 24 3 1 #" "
0 0 21 3 2 #"-3"
0 0 24 3 2 #") "
0 0 21 3 1 #"1"
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 4 #"    "
0 0 24 29 1 #"\n"
0 0 24 3 4 #"    "
0 0 17 3 25 #"#| Further tests, for Q1:"
0 0 17 29 1 #"\n"
0 0 17 3 23 #"    [\"(3.0 mod 4.0)\" 3]"
0 0 17 29 1 #"\n"
0 0 17 3 35 #"    [\"(( 5.0 add 6.0 ) mod 3.0)\" 2]"
0 0 17 29 1 #"\n"
0 0 17 3 25 #"    [\"(8.1 mod 3.0)\" 2.1]"
0 0 17 29 1 #"\n"
0 0 17 3 25 #"    [\"(8.0 mod 3.1)\" 1.8]"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"    [\"(-8.1 mod 3.0)\" 0.9]"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"    [\"(-8.0 mod 3.1)\" 1.3]"
0 0 17 29 1 #"\n"
0 0 17 3 25 #"    [\"(8.1 mod -3)\" -0.9]"
0 0 17 29 1 #"\n"
0 0 17 3 27 #"    [\"(8.0 mod -3.1)\" -1.3]"
0 0 17 29 1 #"\n"
0 0 17 3 28 #"    [\"(-8.1 mod -3.0)\" -2.1]"
0 0 17 29 1 #"\n"
0 0 17 3 28 #"    [\"(-8.0 mod -3.1)\" -1.8]"
0 0 17 29 1 #"\n"
0 0 17 3 25 #"    [\"(8.0  mod  2.0)\" 0]"
0 0 17 29 1 #"\n"
0 0 17 3 25 #"    [\"(-8.0  mod 2.0)\" 0]"
0 0 17 29 1 #"\n"
0 0 17 3 25 #"    [\"(8.0 mod  -2.0)\" 0]"
0 0 17 29 1 #"\n"
0 0 17 3 25 #"    [\"(-8.0 mod -2.0)\" 0]"
0 0 17 29 1 #"\n"
0 0 17 3 25 #"    [\"(8.0  mod  3.0)\" 2]"
0 0 17 29 1 #"\n"
0 0 17 3 25 #"    [\"(-8.0  mod 3.0)\" 1]"
0 0 17 29 1 #"\n"
0 0 17 3 26 #"    [\"(8.0 mod  -3.0)\" -1]"
0 0 17 29 1 #"\n"
0 0 17 3 11 #"    [\"(-8.0"
0 0 17 3 15 #" mod -3.0)\" -2]"
0 0 17 29 1 #"\n"
0 0 17 3 6 #"    |#"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"    })"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 51 #"; For info on backquote, see documentations and/or:"
0 0 24 29 1 #"\n"
0 0 17 3 76
(
 #";   http://www.radford.edu/itec380/2014fall-ibarland/Lectures/backqu"
 #"ote.html"
) 0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 49 #"; Given a string, return a list of tokens (of Q)."
0 0 24 29 1 #"\n"
0 0 17 3 1 #";"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 16 #"string->Q-tokens"
0 0 24 3 1 #" "
0 0 14 3 3 #"str"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 2 #"  "
0 0 17 3 86
(
 #"; Don't use scheme's built-in `read`, because our string might conta"
 #"in semicolons etc."
) 0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 3 #"let"
0 0 24 3 1 #" "
0 0 14 3 4 #"loop"
0 0 24 3 3 #" {["
0 0 14 3 4 #"scnr"
0 0 24 3 2 #" ("
0 0 14 3 14 #"create-scanner"
0 0 24 3 1 #" "
0 0 14 3 3 #"str"
0 0 24 3 4 #")]} "
0 0 17 3 38 #"; See \"named let\" -- advanced-student."
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 11 #"eof-object?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"peek"
0 0 24 3 1 #" "
0 0 14 3 4 #"scnr"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"        "
0 0 14 3 5 #"empty"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"        ("
0 0 14 3 4 #"cons"
0 0 24 3 2 #" ("
0 0 14 3 4 #"pop!"
0 0 24 3 1 #" "
0 0 14 3 4 #"scnr"
0 0 24 3 3 #") ("
0 0 14 3 4 #"loop"
0 0 24 3 1 #" "
0 0 14 3 4 #"scnr"
0 0 24 3 5 #")))))"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"        "
0 0 17 3 42 #"; N.B. We RELY on left-to-right eval here:"
0 0 24 29 1 #"\n"
0 0 24 3 8 #"        "
0 0 17 3 38 #"; the pop happens before looping back."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 36 #"; Test the internal representations:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 8 #"for-each"
0 0 24 3 2 #" ("
0 0 15 3 2 #"\316\273"
0 0 24 3 2 #" ("
0 0 14 3 1 #"t"
0 0 24 3 3 #") ("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 2 #" ("
0 0 14 3 5 #"first"
0 0 24 3 1 #" "
0 0 14 3 1 #"t"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 32 #"                               ("
0 0 14 3 5 #"third"
0 0 24 3 1 #" "
0 0 14 3 1 #"t"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 11 #"          ("
0 0 14 3 6 #"filter"
0 0 24 3 2 #" ("
0 0 15 3 2 #"\316\273"
0 0 24 3 1 #"("
0 0 14 3 1 #"t"
0 0 24 3 3 #") ("
0 0 14 3 2 #">="
0 0 24 3 2 #" ("
0 0 14 3 6 #"length"
0 0 24 3 1 #" "
0 0 14 3 1 #"t"
0 0 24 3 2 #") "
0 0 21 3 1 #"3"
0 0 24 3 3 #")) "
0 0 14 3 5 #"tests"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 55 #"; Test that expr->string and string->expr are inverses:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 8 #"for-each"
0 0 24 3 2 #" ("
0 0 15 3 2 #"\316\273"
0 0 24 3 2 #" ("
0 0 14 3 1 #"t"
0 0 24 3 3 #") ("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 16 #"string->Q-tokens"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 2 #" ("
0 0 14 3 5 #"first"
0 0 24 3 1 #" "
0 0 14 3 1 #"t"
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 0 24 3 32 #"                               ("
0 0 14 3 16 #"string->Q-tokens"
0 0 24 3 2 #" ("
0 0 14 3 5 #"first"
0 0 24 3 1 #" "
0 0 14 3 1 #"t"
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 14 3 5 #"tests"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 19 #"; Now, test `eval`:"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 8 #"for-each"
0 0 24 3 2 #" ("
0 0 15 3 2 #"\316\273"
0 0 24 3 2 #" ("
0 0 14 3 1 #"t"
0 0 24 3 3 #") ("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 2 #" ("
0 0 14 3 5 #"first"
0 0 24 3 1 #" "
0 0 14 3 1 #"t"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 32 #"                               ("
0 0 14 3 6 #"second"
0 0 24 3 1 #" "
0 0 14 3 1 #"t"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"          "
0 0 14 3 5 #"tests"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 25 #";; Forrest Meade (fmeade)"
0 0 24 29 1 #"\n"
0 0 17 3 26 #";; HW07 Test Cases Q1 & Q2"
0 0 24 29 1 #"\n"
0 0 17 3 11 #";; ITEC 380"
0 0 24 29 1 #"\n"
0 0 17 3 20 #";; November 20, 2015"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 3 #"Q1:"
0 0 17 29 1 #"\n"
0 0 17 3 16 #"  Expr       ::="
0 0 17 3 52 #" Num | ParenExpr | BinExpr | ParityExpr | IfZeroExpr"
0 0 17 29 1 #"\n"
0 0 17 3 27 #"  ParenExpr  ::= [[ Expr ]]"
0 0 17 29 1 #"\n"
0 0 17 3 36 #"  BinExpr    ::= ( Expr BinOp Expr )"
0 0 17 29 1 #"\n"
0 0 17 3 51 #"  ParityExpr ::= parity Expr even: Expr odd: Expr ;"
0 0 17 29 1 #"\n"
0 0 17 3 54 #"  IfZeroExpr ::= if Expr is zero then Expr else Expr @"
0 0 17 29 1 #"\n"
0 0 17 3 31 #"  BinOp      ::= add | sub | mu"
0 0 17 3 7 #"l | mod"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;;;;;;;;;;;;;;;;;; TEST CASES: Q1 ;;;;;;;;;;;;;;;;"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 7 #"require"
0 0 24 3 1 #" "
0 0 14 3 8 #"rackunit"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog11"
0 0 24 3 1 #" "
0 0 19 3 18 #"\"( 8.1 mod [[3]])\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog11"
0 0 24 3 3 #") ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 5 #"81/10"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"mod\""
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog11"
0 0 24 3 3 #")) "
0 0 19 3 19 #"\"(81/10 mod [[3]])\""
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog11"
0 0 24 3 4 #"))  "
0 0 21 3 5 #"21/10"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog12"
0 0 24 3 1 #" "
0 0 19 3 41 #"\"if ( 5 sub 5 ) is zero then 0 else -1 @\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog12"
0 0 24 3 3 #") ("
0 0 14 3 16 #"make-ifzero-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"sub\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 2 #") "
0 0 21 3 1 #"0"
0 0 24 3 1 #" "
0 0 21 3 2 #"-1"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog12"
0 0 24 3 3 #")) "
0 0 19 3 39 #"\"if (5 sub 5) is zero then 0 else -1 @\""
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog12"
0 0 24 3 4 #"))  "
0 0 21 3 1 #"0"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog13"
0 0 24 3 1 #" "
0 0 19 3 58
#"\"( [[9]] mod if ( 5 sub [[5]] ) is zero then 3 else 6 @ )\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog13"
0 0 24 3 3 #") ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"9"
0 0 24 3 2 #") "
0 0 19 3 5 #"\"mod\""
0 0 24 3 2 #" ("
0 0 14 3 16 #"make-ifzero-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"sub\""
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 3 #")) "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 21 3 1 #"6"
0 0 24 3 4 #")) )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog13"
0 0 24 3 3 #")) "
0 0 19 3 54 #"\"([[9]] mod if (5 sub [[5]]) is zero then 3 else 6 @)\""
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog13"
0 0 24 3 3 #")) "
0 0 21 3 1 #"0"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 3 #"Q2:"
0 0 17 29 1 #"\n"
0 0 17 3 15 #" Expr       ::="
0 0 17 3 67
#" Num | ParenExpr | BinExpr | ParityExpr | IfZeroExpr | Id | LetExpr"
0 0 17 29 1 #"\n"
0 0 17 3 27 #"  ParenExpr  ::= [[ Expr ]]"
0 0 17 29 1 #"\n"
0 0 17 3 36 #"  BinExpr    ::= ( Expr BinOp Expr )"
0 0 17 29 1 #"\n"
0 0 17 3 51 #"  ParityExpr ::= parity Expr even: Expr odd: Expr ;"
0 0 17 29 1 #"\n"
0 0 17 3 54 #"  IfZeroExpr ::= if Expr is zero then Expr else Expr @"
0 0 17 29 1 #"\n"
0 0 17 3 42 #"  LetExpr ::= say Id be Expr in Expr matey"
0 0 17 29 1 #"\n"
0 0 17 3 38 #"  BinOp      ::= add | sub | mul | mod"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;;;;;;;;;;;;;;;;;; TEST CASES: Q2 ;;;;;;;;;;;;;;;;"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog21"
0 0 24 3 1 #" "
0 0 19 3 33 #"\"say x be 5 in ( 4 mul x ) matey\""
0 0 24 3 2 #") "
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog21"
0 0 24 3 3 #") ("
0 0 14 3 13 #"make-let-expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"mul\""
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog21"
0 0 24 3 3 #")) "
0 0 19 3 31 #"\"say x be 5 in (4 mul x) matey\""
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog21"
0 0 24 3 4 #"))  "
0 0 21 3 2 #"20"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 80
(
 #"; Make an additional example, where the `say` is *not* the top-level"
 #" expression:"
) 0 0 24 29 1 #"\n"
0 0 17 3 46 #"; Then, have the three tests for it, as above."
0 0 24 29 1 #"\n"
0 0 17 3 1 #";"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog22"
0 0 24 3 1 #" "
0 0 19 3 43 #"\"( 5 add say x be 5 in ( 4 mul x ) matey )\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog22"
0 0 24 3 3 #") ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"add\""
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-let-expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"mul\""
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog22"
0 0 24 3 3 #")) "
0 0 19 3 39 #"\"(5 add say x be 5 in (4 mul x) matey)\""
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog22"
0 0 24 3 4 #"))  "
0 0 21 3 2 #"25"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog23"
0 0 24 3 1 #" "
0 0 19 3 51 #"\"[[( 5 sub [[say x be 5 in ( 1 mul x ) matey]] )]]\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog23"
0 0 24 3 3 #") ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 29 1 #"\n"
0 0 24 3 68
#"                                                                    "
0 0 19 3 5 #"\"sub\""
0 0 24 29 1 #"\n"
0 0 24 3 69
(
 #"                                                                    "
 #"("
) 0 0 14 3 15 #"make-paren-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-let-expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 29 1 #"\n"
0 0 24 3 100
(
 #"                                                                    "
 #"                                "
) 0 0 21 3 1 #"5"
0 0 24 29 1 #"\n"
0 0 24 3 101
(
 #"                                                                    "
 #"                                ("
) 0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 29 1 #"\n"
0 0 24 3 115
(
 #"                                                                    "
 #"                                               "
) 0 0 19 3 5 #"\"mul\""
0 0 24 29 1 #"\n"
0 0 24 3 115
(
 #"                                                                    "
 #"                                               "
) 0 0 19 3 3 #"\"x\""
0 0 24 3 7 #"))))) )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog23"
0 0 24 3 3 #")) "
0 0 19 3 47 #"\"[[(5 sub [[say x be 5 in (1 mul x) matey]])]]\""
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog23"
0 0 24 3 3 #")) "
0 0 21 3 1 #"0"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 90
(
 #"; The last paragraph of #2 on hw07 mentions that you'll have to do s"
 #"ubstitution in a tree."
) 0 0 24 29 1 #"\n"
0 0 17 3 52 #"; Although `substitute` returns a *tree* (an Expr), "
0 0 24 29 1 #"\n"
0 0 17 3 102
(
 #"; we can use `parse` (a.k.a. string->expr) (already tested!) to help"
 #" us generate our expected-results."
) 0 0 24 29 1 #"\n"
0 0 17 3 1 #";"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 1 #" "
0 0 21 3 1 #"9"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"3\""
0 0 24 3 6 #"))   ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"3\""
0 0 24 3 3 #") )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 1 #" "
0 0 21 3 1 #"9"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 6 #"))   ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"9\""
0 0 24 3 3 #") )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"z\""
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 6 #"))   ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 3 #") )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"z\""
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 11 #"\"(4 add z)\""
0 0 24 3 5 #"))  ("
0 0 14 3 12 #"string->expr"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"add\""
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 5 #"))) )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"z\""
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 31 #"\"say x be z in (x mul z) matey\""
0 0 24 3 4 #")) ("
0 0 14 3 12 #"string->expr"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-let-expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 1 #" "
0 0 19 3 5 #"\"mul\""
0 0 24 3 1 #" "
0 0 21 3 1 #"7"
0 0 24 3 6 #")))) )"
0 0 24 29 1 #"\n"
0 0 17 3 67
#"; Give at least one more interesting tree, to test `substitute` on,"
0 0 24 29 1 #"\n"
0 0 17 3 41 #"; with parse-tree of height of 2 or more."
0 0 24 29 1 #"\n"
0 0 17 3 95
(
 #"; You do *not* need to do `substitute` on a parse tree containing a "
 #"`say` inside of it ... yet."
) 0 0 24 29 1 #"\n"
0 0 17 3 94
(
 #"; (But you are encouraged to start thinking about what you want to h"
 #"appen, in that situation.)"
) 0 0 24 29 1 #"\n"
0 0 17 3 1 #";"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"y\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 38 #"\"( ( y add 5 ) sub ( [[10]] sub y ) )\""
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 12 #"string->expr"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"add\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 2 #") "
0 0 19 3 5 #"\"sub\""
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 1 #" "
0 0 21 3 2 #"10"
0 0 24 3 2 #") "
0 0 19 3 5 #"\"sub\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 6 #")))) )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 3 #"Q3:"
0 0 17 29 1 #"\n"
0 0 17 3 82
(
 #" Expr       ::= Num | ParenExpr | BinExpr | ParityExpr | IfZeroExpr "
 #"| Id | LetExpr"
) 0 0 17 29 1 #"\n"
0 0 17 3 27 #"  ParenExpr  ::= [[ Expr ]]"
0 0 17 29 1 #"\n"
0 0 17 3 36 #"  BinExpr    ::= ( Expr BinOp Expr )"
0 0 17 29 1 #"\n"
0 0 17 3 51 #"  ParityExpr ::= parity Expr even: Expr odd: Expr ;"
0 0 17 29 1 #"\n"
0 0 17 3 54 #"  IfZeroExpr ::= if Expr is zero then Expr else Expr @"
0 0 17 29 1 #"\n"
0 0 17 3 42 #"  LetExpr ::= say Id be Expr in Expr matey"
0 0 17 29 1 #"\n"
0 0 17 3 38 #"  BinOp      ::= add | sub | mul | mod"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;;;;;;;;;;;;;;;;;; TEST CASES: Q3 ;;;;;;;;;;;;;;;;"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 23 #"#| Problem #4 from HW08"
0 0 17 29 1 #"\n"
0 0 17 3 97
(
 #"a. say y be 3 in say x be 5 in (x add y) matey matey \342\207\222 sa"
 #"y x be 5 in (x add 3) matey \342\207\222 (5 add"
) 0 0 17 3 9 #" 3) \342\207\222 8"
0 0 17 29 1 #"\n"
0 0 17 3 106
(
 #"b. say y be 3 in say x be y in (x add y) matey matey \342\207\222 sa"
 #"y x be 3 in (x add 3) matey \342\207\222 (3 add 3) \342\207\222 6"
) 0 0 17 29 1 #"\n"
0 0 17 3 142
(
 #"c. say x be 5 in say y be 3 in (say x be y in (x add y) matey add x)"
 #" matey matey \342\207\222 say y be 3 in (say x be y in (x add y) mat"
 #"ey add 5) matey"
) 0 0 17 29 1 #"\n"
0 0 17 3 8 #"     \342\207\222"
0 0 17 3 81
(
 #" (say x be 3 in (x add 3) matey add 5) \342\207\222 ((3 add 3) add 5"
 #") \342\207\222 (6 add 5) \342\207\222 11"
) 0 0 17 29 1 #"\n"
0 0 17 3 8 #"d. say x"
0 0 17 29 1 #"\n"
0 0 17 3 7 #"   be 5"
0 0 17 29 1 #"\n"
0 0 17 3 13 #"   in [[say x"
0 0 17 29 1 #"\n"
0 0 17 3 20 #"        be (x add 1)"
0 0 17 29 1 #"\n"
0 0 17 3 34 #"        in (x add 2) matey]] matey"
0 0 17 29 1 #"\n"
0 0 17 3 8 #"e. say y"
0 0 17 29 1 #"\n"
0 0 17 3 11 #"   be say z"
0 0 17 29 1 #"\n"
0 0 17 3 10 #"      be 4"
0 0 17 29 1 #"\n"
0 0 17 3 16 #"      in [[say y"
0 0 17 29 1 #"\n"
0 0 17 3 16 #"           be 99"
0 0 17 29 1 #"\n"
0 0 17 3 29 #"           in z matey]] matey"
0 0 17 29 1 #"\n"
0 0 17 3 13 #"   in [[say z"
0 0 17 29 1 #"\n"
0 0 17 3 12 #"        be 5"
0 0 17 29 1 #"\n"
0 0 17 3 19 #"        in ([[say z"
0 0 17 29 1 #"\n"
0 0 17 3 19 #"              be 10"
0 0 17 29 1 #"\n"
0 0 17 3 55 #"              in y matey]] add (y add z)) matey]] matey"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog31"
0 0 24 3 1 #" "
0 0 19 3 51 #"\"say y be 3 in say x be 5 in (x add y) matey matey\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog31"
0 0 24 3 4 #"))  "
0 0 21 3 1 #"8"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"y\""
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 11 #"\"(x add y)\""
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 12 #"string->expr"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"add\""
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 5 #"))) )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog32"
0 0 24 3 1 #" "
0 0 19 3 51 #"\"say y be 3 in say x be y in (x add y) matey matey\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog32"
0 0 24 3 4 #"))  "
0 0 21 3 1 #"6"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"y\""
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 3 1 #" "
0 0 19 3 3 #"\"y\""
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 11 #"\"(x add y)\""
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 12 #"string->expr"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 19 3 5 #"\"add\""
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 5 #"))) )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog33"
0 0 24 3 1 #" "
0 0 19 3 4 #"\"say"
0 0 19 3 1 #" "
0 0 19 3 1 #"x"
0 0 19 3 1 #" "
0 0 19 3 2 #"be"
0 0 19 3 1 #" "
0 0 19 3 1 #"5"
0 0 19 3 1 #" "
0 0 19 3 3 #"in "
0 0 19 3 3 #"say"
0 0 19 3 2 #" y"
0 0 19 3 1 #" "
0 0 19 3 2 #"be"
0 0 19 3 2 #" 3"
0 0 19 3 3 #" in"
0 0 19 3 2 #" ("
0 0 19 3 4 #"say "
0 0 19 3 2 #"x "
0 0 19 3 2 #"be"
0 0 19 3 2 #" y"
0 0 19 3 1 #" "
0 0 19 3 4 #"in ("
0 0 19 3 2 #"x "
0 0 19 3 3 #"add"
0 0 19 3 1 #" "
0 0 19 3 3 #"y) "
0 0 19 3 5 #"matey"
0 0 19 3 4 #" add"
0 0 19 3 1 #" "
0 0 19 3 1 #"x"
0 0 19 3 2 #") "
0 0 19 3 12 #"matey matey\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog33"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 13 #"make-let-expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 29 1 #"\n"
0 0 24 3 29 #"                             "
0 0 21 3 1 #"5"
0 0 24 29 1 #"\n"
0 0 24 3 30 #"                             ("
0 0 14 3 13 #"make-let-expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"y\""
0 0 24 29 1 #"\n"
0 0 24 3 44 #"                                            "
0 0 21 3 1 #"3"
0 0 24 29 1 #"\n"
0 0 24 3 45 #"                                            ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 29 1 #"\n"
0 0 24 3 46 #"                                             ("
0 0 14 3 13 #"make-let-expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 29 1 #"\n"
0 0 24 3 60
#"                                                            "
0 0 19 3 3 #"\"y\""
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"x\""
0 0 24 29 1 #"\n"
0 0 24 3 44 #"                                            "
0 0 24 3 1 #" "
0 0 24 3 34 #"                                  "
0 0 19 3 5 #"\"add\""
0 0 24 29 1 #"\n"
0 0 24 3 79
(
 #"                                                                    "
 #"           "
) 0 0 19 3 3 #"\"y\""
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 45 #"                                             "
0 0 19 3 5 #"\"add\""
0 0 24 29 1 #"\n"
0 0 24 3 45 #"                                             "
0 0 19 3 3 #"\"x\""
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog33"
0 0 24 3 4 #"))  "
0 0 21 3 2 #"11"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"x"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"y"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"x"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 19 3 2 #"\"y"
0 0 19 3 1 #"\""
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 1 #"\""
0 0 19 3 1 #"("
0 0 19 3 1 #"x"
0 0 19 3 1 #" "
0 0 19 3 3 #"add"
0 0 19 3 1 #" "
0 0 19 3 3 #"y)\""
0 0 24 3 3 #")) "
0 0 19 3 4 #"\"add"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 19 3 2 #"\"x"
0 0 19 3 1 #"\""
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 12 #"string->expr"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 1 #" "
0 0 19 3 4 #"\"add"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 1 #"3"
0 0 24 3 2 #") "
0 0 19 3 4 #"\"add"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 5 #"))) )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog34"
0 0 24 3 1 #" "
0 0 19 3 1 #"\""
0 0 19 3 3 #"say"
0 0 19 3 1 #" "
0 0 19 3 1 #"x"
0 0 19 3 1 #" "
0 0 19 3 2 #"be"
0 0 19 3 1 #" "
0 0 19 3 1 #"5"
0 0 19 3 1 #" "
0 0 19 3 2 #"in"
0 0 19 3 3 #" [["
0 0 19 3 3 #"say"
0 0 19 3 1 #" "
0 0 19 3 1 #"x"
0 0 19 3 1 #" "
0 0 19 3 2 #"be"
0 0 19 3 2 #" ("
0 0 19 3 2 #"x "
0 0 19 3 3 #"add"
0 0 19 3 1 #" "
0 0 19 3 1 #"1"
0 0 19 3 2 #") "
0 0 19 3 2 #"in"
0 0 19 3 2 #" ("
0 0 19 3 1 #"x"
0 0 19 3 1 #" "
0 0 19 3 3 #"add"
0 0 19 3 1 #" "
0 0 19 3 1 #"2"
0 0 19 3 2 #") "
0 0 19 3 5 #"matey"
0 0 19 3 8 #"]] matey"
0 0 19 3 1 #"\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog34"
0 0 24 3 4 #"))  "
0 0 21 3 1 #"8"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"x"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"x"
0 0 19 3 1 #"\""
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 1 #"\""
0 0 19 3 1 #"("
0 0 19 3 1 #"x"
0 0 19 3 1 #" "
0 0 19 3 3 #"add"
0 0 19 3 1 #" "
0 0 19 3 2 #"1)"
0 0 19 3 1 #"\""
0 0 24 3 3 #") ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 1 #"\""
0 0 19 3 1 #"("
0 0 19 3 1 #"x"
0 0 19 3 1 #" "
0 0 19 3 3 #"add"
0 0 19 3 1 #" "
0 0 19 3 2 #"2)"
0 0 19 3 1 #"\""
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 12 #"string->expr"
0 0 24 3 2 #" ("
0 0 14 3 12 #"expr->string"
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 1 #" "
0 0 19 3 4 #"\"add"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 1 #"1"
0 0 24 3 2 #") "
0 0 19 3 4 #"\"add"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 1 #"2"
0 0 24 3 6 #")))) )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog35"
0 0 24 3 1 #" "
0 0 19 3 1 #"\""
0 0 19 3 3 #"say"
0 0 19 3 1 #" "
0 0 19 3 1 #"y"
0 0 19 3 1 #" "
0 0 19 3 2 #"be"
0 0 19 3 1 #" "
0 0 19 3 3 #"say"
0 0 19 3 1 #" "
0 0 19 3 1 #"z"
0 0 19 3 1 #" "
0 0 19 3 2 #"be"
0 0 19 3 1 #" "
0 0 19 3 1 #"4"
0 0 19 3 1 #" "
0 0 19 3 2 #"in"
0 0 19 3 3 #" [["
0 0 19 3 3 #"say"
0 0 19 3 1 #" "
0 0 19 3 1 #"y"
0 0 19 3 1 #" "
0 0 19 3 2 #"be"
0 0 19 3 1 #" "
0 0 19 3 2 #"99"
0 0 19 3 1 #" "
0 0 19 3 2 #"in"
0 0 19 3 1 #" "
0 0 19 3 1 #"z"
0 0 19 3 1 #" "
0 0 19 3 5 #"matey"
0 0 19 3 3 #"]] "
0 0 19 3 5 #"matey"
0 0 19 3 1 #" "
0 0 19 3 2 #"in"
0 0 19 3 3 #" [["
0 0 19 3 3 #"say"
0 0 19 3 1 #" "
0 0 19 3 1 #"z"
0 0 19 3 1 #" "
0 0 19 3 2 #"be"
0 0 19 3 1 #" "
0 0 19 3 1 #"5"
0 0 19 3 1 #" "
0 0 19 3 2 #"in"
0 0 19 3 4 #" ([["
0 0 19 3 3 #"say"
0 0 19 3 1 #" "
0 0 19 3 1 #"z"
0 0 19 3 1 #" "
0 0 19 3 2 #"be"
0 0 19 3 1 #" "
0 0 19 3 2 #"10"
0 0 19 3 1 #" "
0 0 19 3 2 #"in"
0 0 19 3 1 #" "
0 0 19 3 1 #"y"
0 0 19 3 1 #" "
0 0 19 3 5 #"matey"
0 0 19 3 3 #"]] "
0 0 19 3 3 #"add"
0 0 19 3 2 #" ("
0 0 19 3 1 #"y"
0 0 19 3 1 #" "
0 0 19 3 3 #"add"
0 0 19 3 1 #" "
0 0 19 3 1 #"z"
0 0 19 3 3 #")) "
0 0 19 3 5 #"matey"
0 0 19 3 8 #"]] matey"
0 0 19 3 1 #"\""
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 4 #"eval"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 14 3 6 #"prog35"
0 0 24 3 4 #"))  "
0 0 21 3 2 #"13"
0 0 24 3 2 #" )"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 12 #"check-equal?"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"y"
0 0 19 3 1 #"\""
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"z"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"y"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 2 #"99"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"z"
0 0 19 3 1 #"\""
0 0 24 3 6 #")))) ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"z"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 2 #" ("
0 0 14 3 10 #"substitute"
0 0 24 3 1 #" "
0 0 19 3 2 #"\"z"
0 0 19 3 1 #"\""
0 0 24 3 1 #" "
0 0 21 3 2 #"10"
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 3 #"\"y\""
0 0 24 3 4 #"))) "
0 0 19 3 4 #"\"add"
0 0 19 3 1 #"\""
0 0 24 3 2 #" ("
0 0 14 3 12 #"string->expr"
0 0 24 3 1 #" "
0 0 19 3 1 #"\""
0 0 19 3 1 #"("
0 0 19 3 1 #"y"
0 0 19 3 1 #" "
0 0 19 3 3 #"add"
0 0 19 3 1 #" "
0 0 19 3 2 #"z)"
0 0 19 3 1 #"\""
0 0 24 3 6 #")))) )"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 3 #")) "
0 0 19 3 5 #"\"add\""
0 0 24 3 2 #" ("
0 0 14 3 13 #"make-bin-expr"
0 0 24 3 2 #" ("
0 0 14 3 15 #"make-paren-expr"
0 0 24 3 1 #" "
0 0 21 3 1 #"4"
0 0 24 3 2 #") "
0 0 19 3 5 #"\"add\""
0 0 24 3 1 #" "
0 0 21 3 1 #"5"
0 0 24 3 5 #"))) )"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #"#|"
0 0 17 29 1 #"\n"
0 0 17 3 3 #"Q4:"
0 0 17 29 1 #"\n"
0 0 17 3 113
(
 #" Expr           ::= Num | ParenExpr | BinExpr | ParityExpr | IfZeroE"
 #"xpr | Id | LetExpr | FuncExpr | FuncApplyExpr"
) 0 0 17 29 1 #"\n"
0 0 17 3 30 #"  ParenExpr     ::= [[ Expr ]]"
0 0 17 29 1 #"\n"
0 0 17 3 39 #"  BinExpr       ::= ( Expr BinOp Expr )"
0 0 17 29 1 #"\n"
0 0 17 3 54 #"  ParityExpr    ::= parity Expr even: Expr odd: Expr ;"
0 0 17 29 1 #"\n"
0 0 17 3 57 #"  IfZeroExpr    ::= if Expr is zero then Expr else Expr @"
0 0 17 29 1 #"\n"
0 0 17 3 48 #"  LetExpr       ::= say Id be Expr in Expr matey"
0 0 17 29 1 #"\n"
0 0 17 3 34 #"  FuncExpr      ::= (Id) -> {Expr}"
0 0 17 29 1 #"\n"
0 0 17 3 33 #"  FuncApplyExpr ::= <Expr @ Expr>"
0 0 17 29 1 #"\n"
0 0 17 3 41 #"  BinOp         ::= add | sub | mul | mod"
0 0 17 29 1 #"\n"
0 0 17 3 2 #"|#"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 51 #";;;;;;;;;;;;;;;;;;; TEST CASES: Q4 ;;;;;;;;;;;;;;;;"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 16 #";; #6 Test Cases"
0 0 24 29 1 #"\n"
0 0 17 3 13 #"; (x) -> {17}"
0 0 24 29 1 #"\n"
0 0 17 3 22 #"; (x) -> {(x \"mul\" x)}"
0 0 24 29 1 #"\n"
0 0 17 3 13 #"; (x) -> {..."
0 0 17 3 1 #"}"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0           0
